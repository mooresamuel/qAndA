{"ast":null,"code":"import { API_URL } from \"../utils/constants\";\nexport async function textToSpeechAPI(message) {\n  const options = {\n    method: \"POST\",\n    headers: {\n      Accept: \"audio/pcm\",\n      // Expect raw PCM audio format\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n      message: message\n    }) // Send text message\n  };\n  try {\n    const response = await fetch(`${API_URL}/speak_text`, options);\n    if (!response.ok) {\n      throw new Error(\"Failed to fetch audio\");\n    }\n\n    // Create an AudioContext for handling raw audio data\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    const audioStream = audioContext.createMediaStreamDestination();\n    const scriptProcessor = audioContext.createScriptProcessor(1024, 1, 1); // Buffer size of 1024\n\n    // Connect the script processor to the destination\n    scriptProcessor.connect(audioContext.destination);\n\n    // Handle the response body as a stream of binary data\n    const reader = response.body.getReader();\n\n    // This will allow us to read the response stream in chunks\n    let audioBuffer = [];\n\n    // Read chunks of data from the stream\n    const processStream = async () => {\n      const {\n        done,\n        value\n      } = await reader.read();\n      if (done) {\n        // If no more data, stop processing\n        return;\n      }\n\n      // Push the current chunk to the audio buffer\n      audioBuffer.push(value);\n\n      // Convert the chunks into a buffer and decode to audio data\n      const audioData = new Uint8Array([...audioBuffer].flat());\n\n      // Decode the audio data and play it\n      audioContext.decodeAudioData(audioData.buffer, decodedAudio => {\n        const bufferSource = audioContext.createBufferSource();\n        bufferSource.buffer = decodedAudio;\n        bufferSource.connect(audioContext.destination);\n        bufferSource.start();\n      });\n\n      // Keep processing the next chunk\n      processStream();\n    };\n\n    // Start processing the audio stream\n    processStream();\n  } catch (error) {\n    console.error(\"Error while fetching or playing audio:\", error);\n    throw error;\n  }\n}","map":{"version":3,"names":["API_URL","textToSpeechAPI","message","options","method","headers","Accept","body","JSON","stringify","response","fetch","ok","Error","audioContext","window","AudioContext","webkitAudioContext","audioStream","createMediaStreamDestination","scriptProcessor","createScriptProcessor","connect","destination","reader","getReader","audioBuffer","processStream","done","value","read","push","audioData","Uint8Array","flat","decodeAudioData","buffer","decodedAudio","bufferSource","createBufferSource","start","error","console"],"sources":["/home/samoore/tpd/new/src/services/text2SpeechAPI.js"],"sourcesContent":["import { API_URL } from \"../utils/constants\";\r\n\r\nexport async function textToSpeechAPI(message) {\r\n  const options = {\r\n    method: \"POST\",\r\n    headers: {\r\n      Accept: \"audio/pcm\",  // Expect raw PCM audio format\r\n      \"Content-Type\": \"application/json\",\r\n    },\r\n    body: JSON.stringify({ message: message }),  // Send text message\r\n  };\r\n\r\n  try {\r\n    const response = await fetch(`${API_URL}/speak_text`, options);\r\n\r\n    if (!response.ok) {\r\n      throw new Error(\"Failed to fetch audio\");\r\n    }\r\n\r\n    // Create an AudioContext for handling raw audio data\r\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\r\n    const audioStream = audioContext.createMediaStreamDestination();\r\n    const scriptProcessor = audioContext.createScriptProcessor(1024, 1, 1); // Buffer size of 1024\r\n\r\n    // Connect the script processor to the destination\r\n    scriptProcessor.connect(audioContext.destination);\r\n\r\n    // Handle the response body as a stream of binary data\r\n    const reader = response.body.getReader();\r\n\r\n    // This will allow us to read the response stream in chunks\r\n    let audioBuffer = [];\r\n\r\n    // Read chunks of data from the stream\r\n    const processStream = async () => {\r\n      const { done, value } = await reader.read();\r\n      if (done) {\r\n        // If no more data, stop processing\r\n        return;\r\n      }\r\n\r\n      // Push the current chunk to the audio buffer\r\n      audioBuffer.push(value);\r\n\r\n      // Convert the chunks into a buffer and decode to audio data\r\n      const audioData = new Uint8Array([...audioBuffer].flat());\r\n      \r\n      // Decode the audio data and play it\r\n      audioContext.decodeAudioData(audioData.buffer, (decodedAudio) => {\r\n        const bufferSource = audioContext.createBufferSource();\r\n        bufferSource.buffer = decodedAudio;\r\n        bufferSource.connect(audioContext.destination);\r\n        bufferSource.start();\r\n      });\r\n\r\n      // Keep processing the next chunk\r\n      processStream();\r\n    };\r\n\r\n    // Start processing the audio stream\r\n    processStream();\r\n\r\n  } catch (error) {\r\n    console.error(\"Error while fetching or playing audio:\", error);\r\n    throw error;\r\n  }\r\n}"],"mappings":"AAAA,SAASA,OAAO,QAAQ,oBAAoB;AAE5C,OAAO,eAAeC,eAAeA,CAACC,OAAO,EAAE;EAC7C,MAAMC,OAAO,GAAG;IACdC,MAAM,EAAE,MAAM;IACdC,OAAO,EAAE;MACPC,MAAM,EAAE,WAAW;MAAG;MACtB,cAAc,EAAE;IAClB,CAAC;IACDC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;MAAEP,OAAO,EAAEA;IAAQ,CAAC,CAAC,CAAG;EAC/C,CAAC;EAED,IAAI;IACF,MAAMQ,QAAQ,GAAG,MAAMC,KAAK,CAAC,GAAGX,OAAO,aAAa,EAAEG,OAAO,CAAC;IAE9D,IAAI,CAACO,QAAQ,CAACE,EAAE,EAAE;MAChB,MAAM,IAAIC,KAAK,CAAC,uBAAuB,CAAC;IAC1C;;IAEA;IACA,MAAMC,YAAY,GAAG,KAAKC,MAAM,CAACC,YAAY,IAAID,MAAM,CAACE,kBAAkB,EAAE,CAAC;IAC7E,MAAMC,WAAW,GAAGJ,YAAY,CAACK,4BAA4B,CAAC,CAAC;IAC/D,MAAMC,eAAe,GAAGN,YAAY,CAACO,qBAAqB,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;;IAExE;IACAD,eAAe,CAACE,OAAO,CAACR,YAAY,CAACS,WAAW,CAAC;;IAEjD;IACA,MAAMC,MAAM,GAAGd,QAAQ,CAACH,IAAI,CAACkB,SAAS,CAAC,CAAC;;IAExC;IACA,IAAIC,WAAW,GAAG,EAAE;;IAEpB;IACA,MAAMC,aAAa,GAAG,MAAAA,CAAA,KAAY;MAChC,MAAM;QAAEC,IAAI;QAAEC;MAAM,CAAC,GAAG,MAAML,MAAM,CAACM,IAAI,CAAC,CAAC;MAC3C,IAAIF,IAAI,EAAE;QACR;QACA;MACF;;MAEA;MACAF,WAAW,CAACK,IAAI,CAACF,KAAK,CAAC;;MAEvB;MACA,MAAMG,SAAS,GAAG,IAAIC,UAAU,CAAC,CAAC,GAAGP,WAAW,CAAC,CAACQ,IAAI,CAAC,CAAC,CAAC;;MAEzD;MACApB,YAAY,CAACqB,eAAe,CAACH,SAAS,CAACI,MAAM,EAAGC,YAAY,IAAK;QAC/D,MAAMC,YAAY,GAAGxB,YAAY,CAACyB,kBAAkB,CAAC,CAAC;QACtDD,YAAY,CAACF,MAAM,GAAGC,YAAY;QAClCC,YAAY,CAAChB,OAAO,CAACR,YAAY,CAACS,WAAW,CAAC;QAC9Ce,YAAY,CAACE,KAAK,CAAC,CAAC;MACtB,CAAC,CAAC;;MAEF;MACAb,aAAa,CAAC,CAAC;IACjB,CAAC;;IAED;IACAA,aAAa,CAAC,CAAC;EAEjB,CAAC,CAAC,OAAOc,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,wCAAwC,EAAEA,KAAK,CAAC;IAC9D,MAAMA,KAAK;EACb;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}