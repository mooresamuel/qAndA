{"ast":null,"code":"import { API_URL } from \"../utils/constants\";\nexport async function textToSpeechAPI(message) {\n  const options = {\n    method: \"POST\",\n    headers: {\n      Accept: \"audio/wav\",\n      // Assuming we're using audio/wav or another format\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n      message: message // The text message to synthesize\n    })\n  };\n  const response = await fetch(`${API_URL}/speak_text`, options);\n  if (!response.ok) {\n    throw new Error(\"Failed to fetch audio\");\n  }\n\n  // Create a MediaSource object to handle streaming\n  const mediaSource = new MediaSource();\n  const audio = new Audio();\n  audio.src = URL.createObjectURL(mediaSource);\n  mediaSource.addEventListener('sourceopen', () => {\n    const sourceBuffer = mediaSource.addSourceBuffer('audio/wav'); // Change MIME type if needed\n\n    const reader = response.body.getReader(); // Get the stream's reader\n    let decoder = new TextDecoder(); // Decoding chunk data\n\n    function readNextChunk() {\n      reader.read().then(({\n        done,\n        value\n      }) => {\n        if (done) {\n          mediaSource.endOfStream(); // End of stream once all chunks are read\n          return;\n        }\n\n        // Append the chunk to the sourceBuffer\n        sourceBuffer.appendBuffer(value);\n        readNextChunk(); // Read the next chunk\n      }).catch(error => {\n        console.error('Error reading stream:', error);\n      });\n    }\n    readNextChunk(); // Start reading chunks\n  });\n  audio.play(); // Start playing once the media source is ready\n\n  return audio;\n}","map":{"version":3,"names":["API_URL","textToSpeechAPI","message","options","method","headers","Accept","body","JSON","stringify","response","fetch","ok","Error","mediaSource","MediaSource","audio","Audio","src","URL","createObjectURL","addEventListener","sourceBuffer","addSourceBuffer","reader","getReader","decoder","TextDecoder","readNextChunk","read","then","done","value","endOfStream","appendBuffer","catch","error","console","play"],"sources":["/home/samoore/tpd/new/src/services/text2SpeechAPI.js"],"sourcesContent":["import { API_URL } from \"../utils/constants\";\r\n\r\nexport async function textToSpeechAPI(message) {\r\n  const options = {\r\n    method: \"POST\",\r\n    headers: {\r\n      Accept: \"audio/wav\",  // Assuming we're using audio/wav or another format\r\n      \"Content-Type\": \"application/json\",\r\n    },\r\n    body: JSON.stringify({\r\n      message: message,  // The text message to synthesize\r\n    }),\r\n  };\r\n\r\n  const response = await fetch(`${API_URL}/speak_text`, options);\r\n\r\n  if (!response.ok) {\r\n    throw new Error(\"Failed to fetch audio\");\r\n  }\r\n\r\n  // Create a MediaSource object to handle streaming\r\n  const mediaSource = new MediaSource();\r\n  const audio = new Audio();\r\n  audio.src = URL.createObjectURL(mediaSource);\r\n\r\n  mediaSource.addEventListener('sourceopen', () => {\r\n    const sourceBuffer = mediaSource.addSourceBuffer('audio/wav');  // Change MIME type if needed\r\n\r\n    const reader = response.body.getReader();  // Get the stream's reader\r\n    let decoder = new TextDecoder();  // Decoding chunk data\r\n\r\n    function readNextChunk() {\r\n      reader.read().then(({ done, value }) => {\r\n        if (done) {\r\n          mediaSource.endOfStream();  // End of stream once all chunks are read\r\n          return;\r\n        }\r\n\r\n        // Append the chunk to the sourceBuffer\r\n        sourceBuffer.appendBuffer(value);\r\n        readNextChunk();  // Read the next chunk\r\n      }).catch(error => {\r\n        console.error('Error reading stream:', error);\r\n      });\r\n    }\r\n\r\n    readNextChunk();  // Start reading chunks\r\n  });\r\n\r\n  audio.play();  // Start playing once the media source is ready\r\n\r\n  return audio;\r\n}\r\n\r\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,oBAAoB;AAE5C,OAAO,eAAeC,eAAeA,CAACC,OAAO,EAAE;EAC7C,MAAMC,OAAO,GAAG;IACdC,MAAM,EAAE,MAAM;IACdC,OAAO,EAAE;MACPC,MAAM,EAAE,WAAW;MAAG;MACtB,cAAc,EAAE;IAClB,CAAC;IACDC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;MACnBP,OAAO,EAAEA,OAAO,CAAG;IACrB,CAAC;EACH,CAAC;EAED,MAAMQ,QAAQ,GAAG,MAAMC,KAAK,CAAC,GAAGX,OAAO,aAAa,EAAEG,OAAO,CAAC;EAE9D,IAAI,CAACO,QAAQ,CAACE,EAAE,EAAE;IAChB,MAAM,IAAIC,KAAK,CAAC,uBAAuB,CAAC;EAC1C;;EAEA;EACA,MAAMC,WAAW,GAAG,IAAIC,WAAW,CAAC,CAAC;EACrC,MAAMC,KAAK,GAAG,IAAIC,KAAK,CAAC,CAAC;EACzBD,KAAK,CAACE,GAAG,GAAGC,GAAG,CAACC,eAAe,CAACN,WAAW,CAAC;EAE5CA,WAAW,CAACO,gBAAgB,CAAC,YAAY,EAAE,MAAM;IAC/C,MAAMC,YAAY,GAAGR,WAAW,CAACS,eAAe,CAAC,WAAW,CAAC,CAAC,CAAE;;IAEhE,MAAMC,MAAM,GAAGd,QAAQ,CAACH,IAAI,CAACkB,SAAS,CAAC,CAAC,CAAC,CAAE;IAC3C,IAAIC,OAAO,GAAG,IAAIC,WAAW,CAAC,CAAC,CAAC,CAAE;;IAElC,SAASC,aAAaA,CAAA,EAAG;MACvBJ,MAAM,CAACK,IAAI,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC;QAAEC,IAAI;QAAEC;MAAM,CAAC,KAAK;QACtC,IAAID,IAAI,EAAE;UACRjB,WAAW,CAACmB,WAAW,CAAC,CAAC,CAAC,CAAE;UAC5B;QACF;;QAEA;QACAX,YAAY,CAACY,YAAY,CAACF,KAAK,CAAC;QAChCJ,aAAa,CAAC,CAAC,CAAC,CAAE;MACpB,CAAC,CAAC,CAACO,KAAK,CAACC,KAAK,IAAI;QAChBC,OAAO,CAACD,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;MAC/C,CAAC,CAAC;IACJ;IAEAR,aAAa,CAAC,CAAC,CAAC,CAAE;EACpB,CAAC,CAAC;EAEFZ,KAAK,CAACsB,IAAI,CAAC,CAAC,CAAC,CAAE;;EAEf,OAAOtB,KAAK;AACd","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}