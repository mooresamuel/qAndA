{"ast":null,"code":"var _jsxFileName = \"/home/samoore/tpd/new/src/components/ChatStreamingAudioTranscription/ChatStreamingAudioTranscription.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef, useCallback } from \"react\";\nimport { API_URL } from \"../../utils/constants\";\nimport { io } from \"socket.io-client\";\nimport { Mic, MicOff, Activity, Import } from \"lucide-react\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { faMicrophone } from \"@fortawesome/free-solid-svg-icons/faMicrophone\";\nimport \"./ChatStreamingAudioTranscription.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ChatStreamingAudioTranscription = ({\n  isWaiting,\n  setIsWaiting,\n  transcript,\n  setTranscript\n}) => {\n  _s();\n  const [isRecording, setIsRecording] = useState(false);\n  const [isConnected, setIsConnected] = useState(false);\n  const [audioLevel, setAudioLevel] = useState(0);\n  const [error, setError] = useState(\"\");\n  const [chat, setChat] = useState([]);\n  const socketRef = useRef(null);\n  const mediaRecorderRef = useRef(null);\n  const audioContextRef = useRef(null);\n  const analyserRef = useRef(null);\n  const animationFrameRef = useRef(null);\n  const transcriptRef = useRef(transcript);\n  const updateTranscript = useCallback(data => {\n    setTranscript(prev => {\n      const newTranscription = data.transcript.trim();\n      // console.log('newTranscription:', newTranscription);\n      if (newTranscription === \"\") {\n        return prev;\n      }\n      transcriptRef.current = newTranscription;\n      return newTranscription + \" \";\n    });\n    // console.log('trasncriptref  :', transcriptRef.current);\n    // console.log('transcript:', transcript);\n  }, []);\n  useEffect(() => {\n    transcriptRef.current = transcript;\n  }, [transcript]);\n  useEffect(() => {\n    // Connect to WebSocket server\n    socketRef.current = io(`${API_URL}`);\n    socketRef.current.on(\"connect\", () => {\n      setIsConnected(true);\n      console.log(\"Connected to server\");\n    });\n    let ignore = false;\n    socketRef.current.on(\"timeout\", data => {\n      console.log(\"timeout event received:\");\n      if (ignore) {\n        console.log(\"Ignoring timeout event\");\n        return;\n      }\n      ignore = true;\n      setIsRecording(e => false);\n      setIsWaiting(e => true);\n      // sendData();\n      setTimeout(() => {\n        ignore = false;\n        setIsWaiting(e => false);\n      }, 1000);\n    });\n    socketRef.current.on(\"transcription\", data => {\n      updateTranscript(data);\n    });\n    return () => {\n      if (socketRef.current) {\n        socketRef.current.disconnect();\n      }\n    };\n  }, [updateTranscript]);\n  const sendData = useCallback(() => {\n    setChat(prevChat => {\n      const newChat = [...prevChat];\n      // setChat(chat => {\n      //   const newChat = [...chat];\n      //   return newChat;\n      // });\n      newChat.push({\n        user: \"user\",\n        message: transcriptRef.current\n      });\n      if (mediaRecorderRef.current && mediaRecorderRef.current.state === \"recording\") {\n        mediaRecorderRef.current.stop();\n        mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());\n      }\n      // if (transcript && transcript.length > 0) {\n      // console.log('transcriptref current:', transcriptRef.current);\n      // console.log('newChat:', newChat);\n      fetchResponse(newChat, transcriptRef.current);\n      // }\n      return newChat;\n    });\n  }, [transcript, transcriptRef, chat]);\n  const fetchResponse = useCallback((newChat, finalTranscript) => {\n    console.log(\"final transcript:\", finalTranscript);\n    console.log(\"newChat:\", newChat);\n    fetch(`${API_URL}/answer_question`, {\n      method: \"POST\",\n      headers: {\n        Accept: \"application/json\",\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        question: finalTranscript,\n        chat: newChat\n      })\n    }).then(response => response.json()).then(data => {\n      // Get the text fields\n      // console.log('Response data:', data);\n      // Display the text fields (e.g., add them to the DOM)\n      // document.getElementById('text1').innerText = textField1;\n      // document.getElementById('text2').innerText = textField2;\n\n      // Decode and play the audio\n      const audioData = data.audio;\n      const audioBlob = new Blob([Uint8Array.from(atob(audioData), c => c.charCodeAt(0))], {\n        type: \"audio/mp3\"\n      });\n      const audioUrl = URL.createObjectURL(audioBlob);\n      const audio = new Audio(audioUrl);\n      audio.onended = () => {\n        setIsWaiting(false);\n        //   setIsListening(false);\n      };\n      // audio.preload = 'auto';\n      audio.play();\n    }).catch(error => {\n      console.error(\"Error:\", error);\n    });\n  });\n  const startRecording = async () => {\n    setIsRecording(true);\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n\n      // Set up audio analysis\n      audioContextRef.current = new AudioContext();\n      analyserRef.current = audioContextRef.current.createAnalyser();\n      const source = audioContextRef.current.createMediaStreamSource(stream);\n      source.connect(analyserRef.current);\n\n      // Configure analyzer\n      analyserRef.current.fftSize = 256;\n      const bufferLength = analyserRef.current.frequencyBinCount;\n      const dataArray = new Uint8Array(bufferLength);\n      const mimeTypes = [\"audio/webm;codecs=opus\", \"audio/ogg\", \"audio/wav\", \"audio/mp4\"];\n      let selectedMimeType = \"\";\n      for (const mimeType of mimeTypes) {\n        if (MediaRecorder.isTypeSupported(mimeType)) {\n          selectedMimeType = mimeType;\n          break;\n        }\n      }\n      console.log(\"mimeType:\", selectedMimeType);\n      // Set up MediaRecorder with specific MIME type\n      // mediaRecorderRef.current = new MediaRecorder(stream, { mimeType: selectedMimeType });\n      mediaRecorderRef.current = new MediaRecorder(stream, {\n        mimeType: selectedMimeType || \"\"\n      });\n      mediaRecorderRef.current.ondataavailable = event => {\n        if (event.data.size > 0 && socketRef.current) {\n          // Convert blob to base64 and send to server\n          const reader = new FileReader();\n          reader.onloadend = () => {\n            const base64data = reader.result.split(\",\")[1];\n            socketRef.current.emit(\"audio_chunk\", {\n              audio: base64data\n            });\n          };\n          reader.readAsDataURL(event.data);\n        }\n      };\n\n      // Start recording with small time slices\n      mediaRecorderRef.current.start(100); // Send data every 100ms\n\n      // setTranscript(''); // Clear previous transcript\n      // Notify server to start stream\n      socketRef.current.emit(\"start_audio_stream\");\n\n      // Start audio level monitoring\n      const checkAudioLevel = () => {\n        analyserRef.current.getByteFrequencyData(dataArray);\n        const average = dataArray.reduce((a, b) => a + b) / bufferLength;\n        setAudioLevel(average);\n        animationFrameRef.current = requestAnimationFrame(checkAudioLevel);\n      };\n      checkAudioLevel();\n    } catch (err) {\n      console.error(\"Error accessing microphone:\", err);\n      setIsRecording(false);\n      setIsWaiting(false);\n    }\n  };\n  const stopRecording = transcript => {\n    console.log(\"stopRecording\");\n    // Prevent duplicate calls with same transcript\n    setIsRecording(false);\n    if (!transcript || transcript.length === 0) {\n      return;\n    }\n    setIsWaiting(true);\n    // if (lastTranscript === transcript) {\n    //   console.log('Duplicate transcript detected, stopping');\n    //   setIsWaiting(false);\n    //   return;\n    // }\n\n    // If already stopping, return immediately\n    // if (ignore || isStoppingInProgress) {\n    //   console.log('Already stopping, ignoring call');\n    //   return;\n    // }\n\n    console.log(\"Starting stop recording process\");\n    // isStoppingInProgress = true;\n    // lastTranscript = transcript;\n    // setIgnore(true);\n\n    try {\n      // if (!audioContextRef.current) {\n      //     setIsWaiting(false);\n      //   return;\n      // }\n\n      if (mediaRecorderRef.current && mediaRecorderRef.current.state === \"recording\") {\n        mediaRecorderRef.current.stop();\n        mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());\n      }\n      if (audioContextRef.current) {\n        audioContextRef.current.close();\n      }\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      setAudioLevel(0);\n      // console.log('transcript:', transcript);\n      if (transcript && transcript.length > 0) {\n        // Use a local variable to prevent closure issues\n        const currentTranscript = transcript;\n        setChat(prevChat => {\n          // // Check if this transcript was already added\n          // const isDuplicate = prevChat.some(\n          //   msg => msg.user === 'user' && msg.message === currentTranscript\n          // );\n\n          // if (isDuplicate) {\n          //   console.log('Transcript already in chat, skipping');\n          //   setIsWaiting(false);\n\n          //   return prevChat;\n          // }\n\n          const newChat = [...prevChat];\n          newChat.push({\n            user: \"user\",\n            message: currentTranscript\n          });\n\n          // Move fetchResponse outside of setState to prevent multiple calls\n          // setTimeout(() => {\n          fetchResponse(newChat, currentTranscript);\n          // }, 0);\n\n          return newChat;\n        });\n      }\n      setIsWaiting(false);\n      socketRef.current.emit(\"stop_audio_stream\");\n    } finally {\n      // Reset the flags after a short delay\n      // setTimeout(() => {\n      //   isStoppingInProgress = false;\n      //   lastTranscript = null;\n      // }, 5100);\n    }\n  };\n\n  //   const toggleListening = useCallback(() => {\n\n  //     if (isRecording) {\n  //     //   recognition.stop();\n  //         stopRecording();\n  //     } else {\n  //         setError('');\n  //       try {\n  //         // recognition.start();\n  //         startRecording();\n  //         // setIsRecording(true);\n  //     }   catch (err) {\n  //         console.error('Error starting recording:', err);\n  //         setError('Error accessing microphone. Please check your browser settings.');\n  //       }\n  //     }\n  //   }, [isRecording, setIsRecording]);\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"h-14 w-14 rounded-full bg-slate-300 flex items-center justify-center\",\n    children: /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: !isRecording ? startRecording : stopRecording,\n      disabled: isWaiting,\n      className: \"text-2xl\",\n      children: [!isRecording && !isWaiting && /*#__PURE__*/_jsxDEV(FontAwesomeIcon, {\n        className: \"\",\n        color: \"#3A9F50\",\n        icon: faMicrophone,\n        height: \"100%\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 338,\n        columnNumber: 11\n      }, this), isRecording && /*#__PURE__*/_jsxDEV(FontAwesomeIcon, {\n        className: \"pulsing hover:text-red-500\",\n        color: \"#3A9F50\",\n        icon: faMicrophone,\n        height: \"100%\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 346,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 332,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 331,\n    columnNumber: 5\n  }, this);\n};\n_s(ChatStreamingAudioTranscription, \"3ipR9Paz7fHCYZxkuF9U4ey9lqU=\");\n_c = ChatStreamingAudioTranscription;\nexport default ChatStreamingAudioTranscription;\nvar _c;\n$RefreshReg$(_c, \"ChatStreamingAudioTranscription\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useCallback","API_URL","io","Mic","MicOff","Activity","Import","FontAwesomeIcon","faMicrophone","jsxDEV","_jsxDEV","ChatStreamingAudioTranscription","isWaiting","setIsWaiting","transcript","setTranscript","_s","isRecording","setIsRecording","isConnected","setIsConnected","audioLevel","setAudioLevel","error","setError","chat","setChat","socketRef","mediaRecorderRef","audioContextRef","analyserRef","animationFrameRef","transcriptRef","updateTranscript","data","prev","newTranscription","trim","current","on","console","log","ignore","e","setTimeout","disconnect","sendData","prevChat","newChat","push","user","message","state","stop","stream","getTracks","forEach","track","fetchResponse","finalTranscript","fetch","method","headers","Accept","body","JSON","stringify","question","then","response","json","audioData","audio","audioBlob","Blob","Uint8Array","from","atob","c","charCodeAt","type","audioUrl","URL","createObjectURL","Audio","onended","play","catch","startRecording","navigator","mediaDevices","getUserMedia","AudioContext","createAnalyser","source","createMediaStreamSource","connect","fftSize","bufferLength","frequencyBinCount","dataArray","mimeTypes","selectedMimeType","mimeType","MediaRecorder","isTypeSupported","ondataavailable","event","size","reader","FileReader","onloadend","base64data","result","split","emit","readAsDataURL","start","checkAudioLevel","getByteFrequencyData","average","reduce","a","b","requestAnimationFrame","err","stopRecording","length","close","cancelAnimationFrame","currentTranscript","className","children","onClick","disabled","color","icon","height","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/samoore/tpd/new/src/components/ChatStreamingAudioTranscription/ChatStreamingAudioTranscription.js"],"sourcesContent":["import React, { useState, useEffect, useRef, useCallback } from \"react\";\r\nimport { API_URL } from \"../../utils/constants\";\r\nimport { io } from \"socket.io-client\";\r\nimport { Mic, MicOff, Activity, Import } from \"lucide-react\";\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport { faMicrophone } from \"@fortawesome/free-solid-svg-icons/faMicrophone\";\r\nimport \"./ChatStreamingAudioTranscription.css\";\r\n\r\nconst ChatStreamingAudioTranscription = ({\r\n  isWaiting,\r\n  setIsWaiting,\r\n  transcript,\r\n  setTranscript,\r\n}) => {\r\n  const [isRecording, setIsRecording] = useState(false);\r\n  const [isConnected, setIsConnected] = useState(false);\r\n  const [audioLevel, setAudioLevel] = useState(0);\r\n  const [error, setError] = useState(\"\");\r\n  const [chat, setChat] = useState([]);\r\n  const socketRef = useRef(null);\r\n  const mediaRecorderRef = useRef(null);\r\n  const audioContextRef = useRef(null);\r\n  const analyserRef = useRef(null);\r\n  const animationFrameRef = useRef(null);\r\n  const transcriptRef = useRef(transcript);\r\n\r\n  const updateTranscript = useCallback((data) => {\r\n    setTranscript((prev) => {\r\n      const newTranscription = data.transcript.trim();\r\n      // console.log('newTranscription:', newTranscription);\r\n      if (newTranscription === \"\") {\r\n        return prev;\r\n      }\r\n      transcriptRef.current = newTranscription;\r\n      return newTranscription + \" \";\r\n    });\r\n    // console.log('trasncriptref  :', transcriptRef.current);\r\n    // console.log('transcript:', transcript);\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    transcriptRef.current = transcript;\r\n  }, [transcript]);\r\n\r\n  useEffect(() => {\r\n    // Connect to WebSocket server\r\n    socketRef.current = io(`${API_URL}`);\r\n\r\n    socketRef.current.on(\"connect\", () => {\r\n      setIsConnected(true);\r\n      console.log(\"Connected to server\");\r\n    });\r\n\r\n    let ignore = false;\r\n    socketRef.current.on(\"timeout\", (data) => {\r\n      console.log(\"timeout event received:\");\r\n      if (ignore) {\r\n        console.log(\"Ignoring timeout event\");\r\n        return;\r\n      }\r\n      ignore = true;\r\n      setIsRecording((e) => false);\r\n      setIsWaiting((e) => true);\r\n      // sendData();\r\n      setTimeout(() => {\r\n        ignore = false;\r\n        setIsWaiting((e) => false);\r\n      }, 1000);\r\n    });\r\n\r\n    socketRef.current.on(\"transcription\", (data) => {\r\n      updateTranscript(data);\r\n    });\r\n\r\n    return () => {\r\n      if (socketRef.current) {\r\n        socketRef.current.disconnect();\r\n      }\r\n    };\r\n  }, [updateTranscript]);\r\n\r\n  const sendData = useCallback(() => {\r\n    setChat((prevChat) => {\r\n      const newChat = [...prevChat];\r\n      // setChat(chat => {\r\n      //   const newChat = [...chat];\r\n      //   return newChat;\r\n      // });\r\n      newChat.push({ user: \"user\", message: transcriptRef.current });\r\n      if (\r\n        mediaRecorderRef.current &&\r\n        mediaRecorderRef.current.state === \"recording\"\r\n      ) {\r\n        mediaRecorderRef.current.stop();\r\n        mediaRecorderRef.current.stream\r\n          .getTracks()\r\n          .forEach((track) => track.stop());\r\n      }\r\n      // if (transcript && transcript.length > 0) {\r\n      // console.log('transcriptref current:', transcriptRef.current);\r\n      // console.log('newChat:', newChat);\r\n      fetchResponse(newChat, transcriptRef.current);\r\n      // }\r\n      return newChat;\r\n    });\r\n  }, [transcript, transcriptRef, chat]);\r\n\r\n  const fetchResponse = useCallback((newChat, finalTranscript) => {\r\n    console.log(\"final transcript:\", finalTranscript);\r\n    console.log(\"newChat:\", newChat);\r\n    fetch(`${API_URL}/answer_question`, {\r\n      method: \"POST\",\r\n      headers: {\r\n        Accept: \"application/json\",\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n      body: JSON.stringify({\r\n        question: finalTranscript,\r\n        chat: newChat,\r\n      }),\r\n    })\r\n      .then((response) => response.json())\r\n      .then((data) => {\r\n        // Get the text fields\r\n        // console.log('Response data:', data);\r\n        // Display the text fields (e.g., add them to the DOM)\r\n        // document.getElementById('text1').innerText = textField1;\r\n        // document.getElementById('text2').innerText = textField2;\r\n\r\n        // Decode and play the audio\r\n        const audioData = data.audio;\r\n        const audioBlob = new Blob(\r\n          [Uint8Array.from(atob(audioData), (c) => c.charCodeAt(0))],\r\n          { type: \"audio/mp3\" }\r\n        );\r\n        const audioUrl = URL.createObjectURL(audioBlob);\r\n        const audio = new Audio(audioUrl);\r\n        audio.onended = () => {\r\n          setIsWaiting(false);\r\n          //   setIsListening(false);\r\n        };\r\n        // audio.preload = 'auto';\r\n        audio.play();\r\n      })\r\n      .catch((error) => {\r\n        console.error(\"Error:\", error);\r\n      });\r\n  });\r\n\r\n  const startRecording = async () => {\r\n    setIsRecording(true);\r\n    try {\r\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n\r\n      // Set up audio analysis\r\n      audioContextRef.current = new AudioContext();\r\n      analyserRef.current = audioContextRef.current.createAnalyser();\r\n      const source = audioContextRef.current.createMediaStreamSource(stream);\r\n      source.connect(analyserRef.current);\r\n\r\n      // Configure analyzer\r\n      analyserRef.current.fftSize = 256;\r\n      const bufferLength = analyserRef.current.frequencyBinCount;\r\n      const dataArray = new Uint8Array(bufferLength);\r\n      const mimeTypes = [\r\n        \"audio/webm;codecs=opus\",\r\n        \"audio/ogg\",\r\n        \"audio/wav\",\r\n        \"audio/mp4\",\r\n      ];\r\n\r\n      let selectedMimeType = \"\";\r\n      for (const mimeType of mimeTypes) {\r\n        if (MediaRecorder.isTypeSupported(mimeType)) {\r\n          selectedMimeType = mimeType;\r\n          break;\r\n        }\r\n      }\r\n      console.log(\"mimeType:\", selectedMimeType);\r\n      // Set up MediaRecorder with specific MIME type\r\n      // mediaRecorderRef.current = new MediaRecorder(stream, { mimeType: selectedMimeType });\r\n      mediaRecorderRef.current = new MediaRecorder(stream, {\r\n        mimeType: selectedMimeType || \"\",\r\n      });\r\n\r\n      mediaRecorderRef.current.ondataavailable = (event) => {\r\n        if (event.data.size > 0 && socketRef.current) {\r\n          // Convert blob to base64 and send to server\r\n          const reader = new FileReader();\r\n          reader.onloadend = () => {\r\n            const base64data = reader.result.split(\",\")[1];\r\n            socketRef.current.emit(\"audio_chunk\", { audio: base64data });\r\n          };\r\n          reader.readAsDataURL(event.data);\r\n        }\r\n      };\r\n\r\n      // Start recording with small time slices\r\n      mediaRecorderRef.current.start(100); // Send data every 100ms\r\n\r\n      // setTranscript(''); // Clear previous transcript\r\n      // Notify server to start stream\r\n      socketRef.current.emit(\"start_audio_stream\");\r\n\r\n      // Start audio level monitoring\r\n      const checkAudioLevel = () => {\r\n        analyserRef.current.getByteFrequencyData(dataArray);\r\n        const average = dataArray.reduce((a, b) => a + b) / bufferLength;\r\n        setAudioLevel(average);\r\n        animationFrameRef.current = requestAnimationFrame(checkAudioLevel);\r\n      };\r\n\r\n      checkAudioLevel();\r\n    } catch (err) {\r\n      console.error(\"Error accessing microphone:\", err);\r\n      setIsRecording(false);\r\n      setIsWaiting(false);\r\n    }\r\n  };\r\n\r\n  const stopRecording = (transcript) => {\r\n    console.log(\"stopRecording\");\r\n    // Prevent duplicate calls with same transcript\r\n    setIsRecording(false);\r\n    if (!transcript || transcript.length === 0) {\r\n      return;\r\n    }\r\n    setIsWaiting(true);\r\n    // if (lastTranscript === transcript) {\r\n    //   console.log('Duplicate transcript detected, stopping');\r\n    //   setIsWaiting(false);\r\n    //   return;\r\n    // }\r\n\r\n    // If already stopping, return immediately\r\n    // if (ignore || isStoppingInProgress) {\r\n    //   console.log('Already stopping, ignoring call');\r\n    //   return;\r\n    // }\r\n\r\n    console.log(\"Starting stop recording process\");\r\n    // isStoppingInProgress = true;\r\n    // lastTranscript = transcript;\r\n    // setIgnore(true);\r\n\r\n    try {\r\n      // if (!audioContextRef.current) {\r\n      //     setIsWaiting(false);\r\n      //   return;\r\n      // }\r\n\r\n      if (\r\n        mediaRecorderRef.current &&\r\n        mediaRecorderRef.current.state === \"recording\"\r\n      ) {\r\n        mediaRecorderRef.current.stop();\r\n        mediaRecorderRef.current.stream\r\n          .getTracks()\r\n          .forEach((track) => track.stop());\r\n      }\r\n\r\n      if (audioContextRef.current) {\r\n        audioContextRef.current.close();\r\n      }\r\n\r\n      if (animationFrameRef.current) {\r\n        cancelAnimationFrame(animationFrameRef.current);\r\n      }\r\n\r\n      setAudioLevel(0);\r\n      // console.log('transcript:', transcript);\r\n      if (transcript && transcript.length > 0) {\r\n        // Use a local variable to prevent closure issues\r\n        const currentTranscript = transcript;\r\n\r\n        setChat((prevChat) => {\r\n          // // Check if this transcript was already added\r\n          // const isDuplicate = prevChat.some(\r\n          //   msg => msg.user === 'user' && msg.message === currentTranscript\r\n          // );\r\n\r\n          // if (isDuplicate) {\r\n          //   console.log('Transcript already in chat, skipping');\r\n          //   setIsWaiting(false);\r\n\r\n          //   return prevChat;\r\n          // }\r\n\r\n          const newChat = [...prevChat];\r\n          newChat.push({ user: \"user\", message: currentTranscript });\r\n\r\n          // Move fetchResponse outside of setState to prevent multiple calls\r\n          // setTimeout(() => {\r\n          fetchResponse(newChat, currentTranscript);\r\n          // }, 0);\r\n\r\n          return newChat;\r\n        });\r\n      }\r\n      setIsWaiting(false);\r\n\r\n      socketRef.current.emit(\"stop_audio_stream\");\r\n    } finally {\r\n      // Reset the flags after a short delay\r\n      // setTimeout(() => {\r\n      //   isStoppingInProgress = false;\r\n      //   lastTranscript = null;\r\n      // }, 5100);\r\n    }\r\n  };\r\n\r\n  //   const toggleListening = useCallback(() => {\r\n\r\n  //     if (isRecording) {\r\n  //     //   recognition.stop();\r\n  //         stopRecording();\r\n  //     } else {\r\n  //         setError('');\r\n  //       try {\r\n  //         // recognition.start();\r\n  //         startRecording();\r\n  //         // setIsRecording(true);\r\n  //     }   catch (err) {\r\n  //         console.error('Error starting recording:', err);\r\n  //         setError('Error accessing microphone. Please check your browser settings.');\r\n  //       }\r\n  //     }\r\n  //   }, [isRecording, setIsRecording]);\r\n\r\n  return (\r\n    <div className=\"h-14 w-14 rounded-full bg-slate-300 flex items-center justify-center\">\r\n      <button\r\n        onClick={!isRecording ? startRecording : stopRecording}\r\n        disabled={isWaiting}\r\n        className=\"text-2xl\"\r\n      >\r\n        {!isRecording && !isWaiting && (\r\n          <FontAwesomeIcon\r\n            className=\"\"\r\n            color=\"#3A9F50\"\r\n            icon={faMicrophone}\r\n            height=\"100%\"\r\n          />\r\n        )}\r\n        {isRecording && (\r\n          <FontAwesomeIcon\r\n            className=\"pulsing hover:text-red-500\"\r\n            color=\"#3A9F50\"\r\n            icon={faMicrophone}\r\n            height=\"100%\"\r\n          />\r\n        )}\r\n      </button>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ChatStreamingAudioTranscription;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}