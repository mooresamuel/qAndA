{"ast":null,"code":"import React,{useState,useEffect,useRef,useCallback}from\"react\";import{API_URL}from\"../../utils/constants\";import{io}from\"socket.io-client\";import{Mic,MicOff,Activity,Import}from\"lucide-react\";import{FontAwesomeIcon}from\"@fortawesome/react-fontawesome\";import{faMicrophone}from\"@fortawesome/free-solid-svg-icons/faMicrophone\";import\"./ChatStreamingAudioTranscription.css\";import{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";const ChatStreamingAudioTranscription=_ref=>{let{isWaiting,setIsWaiting,transcript,setTranscript}=_ref;const[isRecording,setIsRecording]=useState(false);const[isConnected,setIsConnected]=useState(false);const[audioLevel,setAudioLevel]=useState(0);const[error,setError]=useState(\"\");const[chat,setChat]=useState([]);const socketRef=useRef(null);const mediaRecorderRef=useRef(null);const audioContextRef=useRef(null);const analyserRef=useRef(null);const animationFrameRef=useRef(null);const transcriptRef=useRef(transcript);const updateTranscript=useCallback(data=>{setTranscript(prev=>{const newTranscription=data.transcript.trim();// console.log('newTranscription:', newTranscription);\nif(newTranscription===\"\"){return prev;}transcriptRef.current=newTranscription;return newTranscription+\" \";});// console.log('trasncriptref  :', transcriptRef.current);\n// console.log('transcript:', transcript);\n},[]);useEffect(()=>{transcriptRef.current=transcript;},[transcript]);useEffect(()=>{// Connect to WebSocket server\nsocketRef.current=io(`${API_URL}`);socketRef.current.on(\"connect\",()=>{setIsConnected(true);console.log(\"Connected to server\");});let ignore=false;socketRef.current.on(\"timeout\",data=>{console.log(\"timeout event received:\");if(ignore){console.log(\"Ignoring timeout event\");return;}ignore=true;setIsRecording(e=>false);setIsWaiting(e=>true);// sendData();\nsetTimeout(()=>{ignore=false;setIsWaiting(e=>false);},1000);});socketRef.current.on(\"transcription\",data=>{updateTranscript(data);});return()=>{if(socketRef.current){socketRef.current.disconnect();}};},[updateTranscript]);const sendData=useCallback(()=>{setChat(prevChat=>{const newChat=[...prevChat];// setChat(chat => {\n//   const newChat = [...chat];\n//   return newChat;\n// });\nnewChat.push({user:\"user\",message:transcriptRef.current});if(mediaRecorderRef.current&&mediaRecorderRef.current.state===\"recording\"){mediaRecorderRef.current.stop();mediaRecorderRef.current.stream.getTracks().forEach(track=>track.stop());}// if (transcript && transcript.length > 0) {\n// console.log('transcriptref current:', transcriptRef.current);\n// console.log('newChat:', newChat);\nfetchResponse(newChat,transcriptRef.current);// }\nreturn newChat;});},[transcript,transcriptRef,chat]);const fetchResponse=useCallback((newChat,finalTranscript)=>{console.log(\"final transcript:\",finalTranscript);console.log(\"newChat:\",newChat);fetch(`${API_URL}/answer_question`,{method:\"POST\",headers:{Accept:\"application/json\",\"Content-Type\":\"application/json\"},body:JSON.stringify({question:finalTranscript,chat:newChat})}).then(response=>response.json()).then(data=>{// Get the text fields\n// console.log('Response data:', data);\n// Display the text fields (e.g., add them to the DOM)\n// document.getElementById('text1').innerText = textField1;\n// document.getElementById('text2').innerText = textField2;\n// Decode and play the audio\nconst audioData=data.audio;const audioBlob=new Blob([Uint8Array.from(atob(audioData),c=>c.charCodeAt(0))],{type:\"audio/mp3\"});const audioUrl=URL.createObjectURL(audioBlob);const audio=new Audio(audioUrl);audio.onended=()=>{setIsWaiting(false);//   setIsListening(false);\n};// audio.preload = 'auto';\naudio.play();}).catch(error=>{console.error(\"Error:\",error);});});const startRecording=async()=>{setIsRecording(true);try{const stream=await navigator.mediaDevices.getUserMedia({audio:true});// Set up audio analysis\naudioContextRef.current=new AudioContext();analyserRef.current=audioContextRef.current.createAnalyser();const source=audioContextRef.current.createMediaStreamSource(stream);source.connect(analyserRef.current);// Configure analyzer\nanalyserRef.current.fftSize=256;const bufferLength=analyserRef.current.frequencyBinCount;const dataArray=new Uint8Array(bufferLength);const mimeTypes=[\"audio/webm;codecs=opus\",\"audio/ogg\",\"audio/wav\",\"audio/mp4\"];let selectedMimeType=\"\";for(const mimeType of mimeTypes){if(MediaRecorder.isTypeSupported(mimeType)){selectedMimeType=mimeType;break;}}console.log(\"mimeType:\",selectedMimeType);// Set up MediaRecorder with specific MIME type\n// mediaRecorderRef.current = new MediaRecorder(stream, { mimeType: selectedMimeType });\nmediaRecorderRef.current=new MediaRecorder(stream,{mimeType:selectedMimeType||\"\"});mediaRecorderRef.current.ondataavailable=event=>{if(event.data.size>0&&socketRef.current){// Convert blob to base64 and send to server\nconst reader=new FileReader();reader.onloadend=()=>{const base64data=reader.result.split(\",\")[1];socketRef.current.emit(\"audio_chunk\",{audio:base64data});};reader.readAsDataURL(event.data);}};// Start recording with small time slices\nmediaRecorderRef.current.start(100);// Send data every 100ms\n// setTranscript(''); // Clear previous transcript\n// Notify server to start stream\nsocketRef.current.emit(\"start_audio_stream\");// Start audio level monitoring\nconst checkAudioLevel=()=>{analyserRef.current.getByteFrequencyData(dataArray);const average=dataArray.reduce((a,b)=>a+b)/bufferLength;setAudioLevel(average);animationFrameRef.current=requestAnimationFrame(checkAudioLevel);};checkAudioLevel();}catch(err){console.error(\"Error accessing microphone:\",err);setIsRecording(false);setIsWaiting(false);}};const stopRecording=transcript=>{console.log(\"stopRecording\");// Prevent duplicate calls with same transcript\nsetIsRecording(false);if(!transcript||transcript.length===0){return;}setIsWaiting(true);// if (lastTranscript === transcript) {\n//   console.log('Duplicate transcript detected, stopping');\n//   setIsWaiting(false);\n//   return;\n// }\n// If already stopping, return immediately\n// if (ignore || isStoppingInProgress) {\n//   console.log('Already stopping, ignoring call');\n//   return;\n// }\nconsole.log(\"Starting stop recording process\");// isStoppingInProgress = true;\n// lastTranscript = transcript;\n// setIgnore(true);\ntry{// if (!audioContextRef.current) {\n//     setIsWaiting(false);\n//   return;\n// }\nif(mediaRecorderRef.current&&mediaRecorderRef.current.state===\"recording\"){mediaRecorderRef.current.stop();mediaRecorderRef.current.stream.getTracks().forEach(track=>track.stop());}if(audioContextRef.current){audioContextRef.current.close();}if(animationFrameRef.current){cancelAnimationFrame(animationFrameRef.current);}setAudioLevel(0);// console.log('transcript:', transcript);\nif(transcript&&transcript.length>0){// Use a local variable to prevent closure issues\nconst currentTranscript=transcript;setChat(prevChat=>{// // Check if this transcript was already added\n// const isDuplicate = prevChat.some(\n//   msg => msg.user === 'user' && msg.message === currentTranscript\n// );\n// if (isDuplicate) {\n//   console.log('Transcript already in chat, skipping');\n//   setIsWaiting(false);\n//   return prevChat;\n// }\nconst newChat=[...prevChat];newChat.push({user:\"user\",message:currentTranscript});// Move fetchResponse outside of setState to prevent multiple calls\n// setTimeout(() => {\nfetchResponse(newChat,currentTranscript);// }, 0);\nreturn newChat;});}setIsWaiting(false);socketRef.current.emit(\"stop_audio_stream\");}finally{// Reset the flags after a short delay\n// setTimeout(() => {\n//   isStoppingInProgress = false;\n//   lastTranscript = null;\n// }, 5100);\n}};//   const toggleListening = useCallback(() => {\n//     if (isRecording) {\n//     //   recognition.stop();\n//         stopRecording();\n//     } else {\n//         setError('');\n//       try {\n//         // recognition.start();\n//         startRecording();\n//         // setIsRecording(true);\n//     }   catch (err) {\n//         console.error('Error starting recording:', err);\n//         setError('Error accessing microphone. Please check your browser settings.');\n//       }\n//     }\n//   }, [isRecording, setIsRecording]);\nreturn/*#__PURE__*/_jsx(\"div\",{className:\"h-14 w-14 rounded-full bg-slate-300 flex items-center justify-center\",children:/*#__PURE__*/_jsxs(\"button\",{onClick:!isRecording?startRecording:stopRecording,disabled:isWaiting,className:\"text-2xl\",children:[!isRecording&&!isWaiting&&/*#__PURE__*/_jsx(FontAwesomeIcon,{className:\"\",color:\"#3A9F50\",icon:faMicrophone,height:\"100%\"}),isRecording&&/*#__PURE__*/_jsx(FontAwesomeIcon,{className:\"pulsing hover:text-red-500\",color:\"#3A9F50\",icon:faMicrophone,height:\"100%\"})]})});};export default ChatStreamingAudioTranscription;","map":{"version":3,"names":["React","useState","useEffect","useRef","useCallback","API_URL","io","Mic","MicOff","Activity","Import","FontAwesomeIcon","faMicrophone","jsx","_jsx","jsxs","_jsxs","ChatStreamingAudioTranscription","_ref","isWaiting","setIsWaiting","transcript","setTranscript","isRecording","setIsRecording","isConnected","setIsConnected","audioLevel","setAudioLevel","error","setError","chat","setChat","socketRef","mediaRecorderRef","audioContextRef","analyserRef","animationFrameRef","transcriptRef","updateTranscript","data","prev","newTranscription","trim","current","on","console","log","ignore","e","setTimeout","disconnect","sendData","prevChat","newChat","push","user","message","state","stop","stream","getTracks","forEach","track","fetchResponse","finalTranscript","fetch","method","headers","Accept","body","JSON","stringify","question","then","response","json","audioData","audio","audioBlob","Blob","Uint8Array","from","atob","c","charCodeAt","type","audioUrl","URL","createObjectURL","Audio","onended","play","catch","startRecording","navigator","mediaDevices","getUserMedia","AudioContext","createAnalyser","source","createMediaStreamSource","connect","fftSize","bufferLength","frequencyBinCount","dataArray","mimeTypes","selectedMimeType","mimeType","MediaRecorder","isTypeSupported","ondataavailable","event","size","reader","FileReader","onloadend","base64data","result","split","emit","readAsDataURL","start","checkAudioLevel","getByteFrequencyData","average","reduce","a","b","requestAnimationFrame","err","stopRecording","length","close","cancelAnimationFrame","currentTranscript","className","children","onClick","disabled","color","icon","height"],"sources":["/home/samoore/tpd/new/src/components/ChatStreamingAudioTranscription/ChatStreamingAudioTranscription.js"],"sourcesContent":["import React, { useState, useEffect, useRef, useCallback } from \"react\";\r\nimport { API_URL } from \"../../utils/constants\";\r\nimport { io } from \"socket.io-client\";\r\nimport { Mic, MicOff, Activity, Import } from \"lucide-react\";\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport { faMicrophone } from \"@fortawesome/free-solid-svg-icons/faMicrophone\";\r\nimport \"./ChatStreamingAudioTranscription.css\";\r\n\r\nconst ChatStreamingAudioTranscription = ({\r\n  isWaiting,\r\n  setIsWaiting,\r\n  transcript,\r\n  setTranscript,\r\n}) => {\r\n  const [isRecording, setIsRecording] = useState(false);\r\n  const [isConnected, setIsConnected] = useState(false);\r\n  const [audioLevel, setAudioLevel] = useState(0);\r\n  const [error, setError] = useState(\"\");\r\n  const [chat, setChat] = useState([]);\r\n  const socketRef = useRef(null);\r\n  const mediaRecorderRef = useRef(null);\r\n  const audioContextRef = useRef(null);\r\n  const analyserRef = useRef(null);\r\n  const animationFrameRef = useRef(null);\r\n  const transcriptRef = useRef(transcript);\r\n\r\n  const updateTranscript = useCallback((data) => {\r\n    setTranscript((prev) => {\r\n      const newTranscription = data.transcript.trim();\r\n      // console.log('newTranscription:', newTranscription);\r\n      if (newTranscription === \"\") {\r\n        return prev;\r\n      }\r\n      transcriptRef.current = newTranscription;\r\n      return newTranscription + \" \";\r\n    });\r\n    // console.log('trasncriptref  :', transcriptRef.current);\r\n    // console.log('transcript:', transcript);\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    transcriptRef.current = transcript;\r\n  }, [transcript]);\r\n\r\n  useEffect(() => {\r\n    // Connect to WebSocket server\r\n    socketRef.current = io(`${API_URL}`);\r\n\r\n    socketRef.current.on(\"connect\", () => {\r\n      setIsConnected(true);\r\n      console.log(\"Connected to server\");\r\n    });\r\n\r\n    let ignore = false;\r\n    socketRef.current.on(\"timeout\", (data) => {\r\n      console.log(\"timeout event received:\");\r\n      if (ignore) {\r\n        console.log(\"Ignoring timeout event\");\r\n        return;\r\n      }\r\n      ignore = true;\r\n      setIsRecording((e) => false);\r\n      setIsWaiting((e) => true);\r\n      // sendData();\r\n      setTimeout(() => {\r\n        ignore = false;\r\n        setIsWaiting((e) => false);\r\n      }, 1000);\r\n    });\r\n\r\n    socketRef.current.on(\"transcription\", (data) => {\r\n      updateTranscript(data);\r\n    });\r\n\r\n    return () => {\r\n      if (socketRef.current) {\r\n        socketRef.current.disconnect();\r\n      }\r\n    };\r\n  }, [updateTranscript]);\r\n\r\n  const sendData = useCallback(() => {\r\n    setChat((prevChat) => {\r\n      const newChat = [...prevChat];\r\n      // setChat(chat => {\r\n      //   const newChat = [...chat];\r\n      //   return newChat;\r\n      // });\r\n      newChat.push({ user: \"user\", message: transcriptRef.current });\r\n      if (\r\n        mediaRecorderRef.current &&\r\n        mediaRecorderRef.current.state === \"recording\"\r\n      ) {\r\n        mediaRecorderRef.current.stop();\r\n        mediaRecorderRef.current.stream\r\n          .getTracks()\r\n          .forEach((track) => track.stop());\r\n      }\r\n      // if (transcript && transcript.length > 0) {\r\n      // console.log('transcriptref current:', transcriptRef.current);\r\n      // console.log('newChat:', newChat);\r\n      fetchResponse(newChat, transcriptRef.current);\r\n      // }\r\n      return newChat;\r\n    });\r\n  }, [transcript, transcriptRef, chat]);\r\n\r\n  const fetchResponse = useCallback((newChat, finalTranscript) => {\r\n    console.log(\"final transcript:\", finalTranscript);\r\n    console.log(\"newChat:\", newChat);\r\n    fetch(`${API_URL}/answer_question`, {\r\n      method: \"POST\",\r\n      headers: {\r\n        Accept: \"application/json\",\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n      body: JSON.stringify({\r\n        question: finalTranscript,\r\n        chat: newChat,\r\n      }),\r\n    })\r\n      .then((response) => response.json())\r\n      .then((data) => {\r\n        // Get the text fields\r\n        // console.log('Response data:', data);\r\n        // Display the text fields (e.g., add them to the DOM)\r\n        // document.getElementById('text1').innerText = textField1;\r\n        // document.getElementById('text2').innerText = textField2;\r\n\r\n        // Decode and play the audio\r\n        const audioData = data.audio;\r\n        const audioBlob = new Blob(\r\n          [Uint8Array.from(atob(audioData), (c) => c.charCodeAt(0))],\r\n          { type: \"audio/mp3\" }\r\n        );\r\n        const audioUrl = URL.createObjectURL(audioBlob);\r\n        const audio = new Audio(audioUrl);\r\n        audio.onended = () => {\r\n          setIsWaiting(false);\r\n          //   setIsListening(false);\r\n        };\r\n        // audio.preload = 'auto';\r\n        audio.play();\r\n      })\r\n      .catch((error) => {\r\n        console.error(\"Error:\", error);\r\n      });\r\n  });\r\n\r\n  const startRecording = async () => {\r\n    setIsRecording(true);\r\n    try {\r\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n\r\n      // Set up audio analysis\r\n      audioContextRef.current = new AudioContext();\r\n      analyserRef.current = audioContextRef.current.createAnalyser();\r\n      const source = audioContextRef.current.createMediaStreamSource(stream);\r\n      source.connect(analyserRef.current);\r\n\r\n      // Configure analyzer\r\n      analyserRef.current.fftSize = 256;\r\n      const bufferLength = analyserRef.current.frequencyBinCount;\r\n      const dataArray = new Uint8Array(bufferLength);\r\n      const mimeTypes = [\r\n        \"audio/webm;codecs=opus\",\r\n        \"audio/ogg\",\r\n        \"audio/wav\",\r\n        \"audio/mp4\",\r\n      ];\r\n\r\n      let selectedMimeType = \"\";\r\n      for (const mimeType of mimeTypes) {\r\n        if (MediaRecorder.isTypeSupported(mimeType)) {\r\n          selectedMimeType = mimeType;\r\n          break;\r\n        }\r\n      }\r\n      console.log(\"mimeType:\", selectedMimeType);\r\n      // Set up MediaRecorder with specific MIME type\r\n      // mediaRecorderRef.current = new MediaRecorder(stream, { mimeType: selectedMimeType });\r\n      mediaRecorderRef.current = new MediaRecorder(stream, {\r\n        mimeType: selectedMimeType || \"\",\r\n      });\r\n\r\n      mediaRecorderRef.current.ondataavailable = (event) => {\r\n        if (event.data.size > 0 && socketRef.current) {\r\n          // Convert blob to base64 and send to server\r\n          const reader = new FileReader();\r\n          reader.onloadend = () => {\r\n            const base64data = reader.result.split(\",\")[1];\r\n            socketRef.current.emit(\"audio_chunk\", { audio: base64data });\r\n          };\r\n          reader.readAsDataURL(event.data);\r\n        }\r\n      };\r\n\r\n      // Start recording with small time slices\r\n      mediaRecorderRef.current.start(100); // Send data every 100ms\r\n\r\n      // setTranscript(''); // Clear previous transcript\r\n      // Notify server to start stream\r\n      socketRef.current.emit(\"start_audio_stream\");\r\n\r\n      // Start audio level monitoring\r\n      const checkAudioLevel = () => {\r\n        analyserRef.current.getByteFrequencyData(dataArray);\r\n        const average = dataArray.reduce((a, b) => a + b) / bufferLength;\r\n        setAudioLevel(average);\r\n        animationFrameRef.current = requestAnimationFrame(checkAudioLevel);\r\n      };\r\n\r\n      checkAudioLevel();\r\n    } catch (err) {\r\n      console.error(\"Error accessing microphone:\", err);\r\n      setIsRecording(false);\r\n      setIsWaiting(false);\r\n    }\r\n  };\r\n\r\n  const stopRecording = (transcript) => {\r\n    console.log(\"stopRecording\");\r\n    // Prevent duplicate calls with same transcript\r\n    setIsRecording(false);\r\n    if (!transcript || transcript.length === 0) {\r\n      return;\r\n    }\r\n    setIsWaiting(true);\r\n    // if (lastTranscript === transcript) {\r\n    //   console.log('Duplicate transcript detected, stopping');\r\n    //   setIsWaiting(false);\r\n    //   return;\r\n    // }\r\n\r\n    // If already stopping, return immediately\r\n    // if (ignore || isStoppingInProgress) {\r\n    //   console.log('Already stopping, ignoring call');\r\n    //   return;\r\n    // }\r\n\r\n    console.log(\"Starting stop recording process\");\r\n    // isStoppingInProgress = true;\r\n    // lastTranscript = transcript;\r\n    // setIgnore(true);\r\n\r\n    try {\r\n      // if (!audioContextRef.current) {\r\n      //     setIsWaiting(false);\r\n      //   return;\r\n      // }\r\n\r\n      if (\r\n        mediaRecorderRef.current &&\r\n        mediaRecorderRef.current.state === \"recording\"\r\n      ) {\r\n        mediaRecorderRef.current.stop();\r\n        mediaRecorderRef.current.stream\r\n          .getTracks()\r\n          .forEach((track) => track.stop());\r\n      }\r\n\r\n      if (audioContextRef.current) {\r\n        audioContextRef.current.close();\r\n      }\r\n\r\n      if (animationFrameRef.current) {\r\n        cancelAnimationFrame(animationFrameRef.current);\r\n      }\r\n\r\n      setAudioLevel(0);\r\n      // console.log('transcript:', transcript);\r\n      if (transcript && transcript.length > 0) {\r\n        // Use a local variable to prevent closure issues\r\n        const currentTranscript = transcript;\r\n\r\n        setChat((prevChat) => {\r\n          // // Check if this transcript was already added\r\n          // const isDuplicate = prevChat.some(\r\n          //   msg => msg.user === 'user' && msg.message === currentTranscript\r\n          // );\r\n\r\n          // if (isDuplicate) {\r\n          //   console.log('Transcript already in chat, skipping');\r\n          //   setIsWaiting(false);\r\n\r\n          //   return prevChat;\r\n          // }\r\n\r\n          const newChat = [...prevChat];\r\n          newChat.push({ user: \"user\", message: currentTranscript });\r\n\r\n          // Move fetchResponse outside of setState to prevent multiple calls\r\n          // setTimeout(() => {\r\n          fetchResponse(newChat, currentTranscript);\r\n          // }, 0);\r\n\r\n          return newChat;\r\n        });\r\n      }\r\n      setIsWaiting(false);\r\n\r\n      socketRef.current.emit(\"stop_audio_stream\");\r\n    } finally {\r\n      // Reset the flags after a short delay\r\n      // setTimeout(() => {\r\n      //   isStoppingInProgress = false;\r\n      //   lastTranscript = null;\r\n      // }, 5100);\r\n    }\r\n  };\r\n\r\n  //   const toggleListening = useCallback(() => {\r\n\r\n  //     if (isRecording) {\r\n  //     //   recognition.stop();\r\n  //         stopRecording();\r\n  //     } else {\r\n  //         setError('');\r\n  //       try {\r\n  //         // recognition.start();\r\n  //         startRecording();\r\n  //         // setIsRecording(true);\r\n  //     }   catch (err) {\r\n  //         console.error('Error starting recording:', err);\r\n  //         setError('Error accessing microphone. Please check your browser settings.');\r\n  //       }\r\n  //     }\r\n  //   }, [isRecording, setIsRecording]);\r\n\r\n  return (\r\n    <div className=\"h-14 w-14 rounded-full bg-slate-300 flex items-center justify-center\">\r\n      <button\r\n        onClick={!isRecording ? startRecording : stopRecording}\r\n        disabled={isWaiting}\r\n        className=\"text-2xl\"\r\n      >\r\n        {!isRecording && !isWaiting && (\r\n          <FontAwesomeIcon\r\n            className=\"\"\r\n            color=\"#3A9F50\"\r\n            icon={faMicrophone}\r\n            height=\"100%\"\r\n          />\r\n        )}\r\n        {isRecording && (\r\n          <FontAwesomeIcon\r\n            className=\"pulsing hover:text-red-500\"\r\n            color=\"#3A9F50\"\r\n            icon={faMicrophone}\r\n            height=\"100%\"\r\n          />\r\n        )}\r\n      </button>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ChatStreamingAudioTranscription;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}