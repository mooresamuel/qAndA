{"ast":null,"code":"import{useEffect,useRef,useState}from\"react\";export function useRecordAudio(){const[isRecording,setIsRecording]=useState(false);const[audioUrl,setAudioUrl]=useState(null);const[isStreamReady,setIsStreamReady]=useState(false);const[error,setError]=useState(null);const mediaStreamRef=useRef(null);const mediaRecorderRef=useRef(null);const audioChunksRef=useRef([]);const audioElementRef=useRef(null);useEffect(()=>{initAudioStream();return()=>{cleanupAudioStream();if(audioUrl){URL.revokeObjectURL(audioUrl);}};},[]);const initAudioStream=async()=>{try{// console.log(\"Requesting microphone access...\");\nconst stream=await navigator.mediaDevices.getUserMedia({audio:{channelCount:1,sampleRate:16000}});// console.log(\"Microphone access granted\");\nmediaStreamRef.current=stream;// Check available MIME types\nconst mimeType=MediaRecorder.isTypeSupported(\"audio/webm\")?\"audio/webm\":MediaRecorder.isTypeSupported(\"audio/mp4\")?\"audio/mp4\":\"audio/ogg\";// console.log(\"Using MIME type:\", mimeType);\nmediaRecorderRef.current=new MediaRecorder(stream,{mimeType:mimeType});mediaRecorderRef.current.ondataavailable=event=>{// console.log(\"Data available:\", event.data.size, \"bytes\");\nif(event.data.size>0){audioChunksRef.current.push(event.data);}};mediaRecorderRef.current.onstart=()=>{// console.log(\"Recording started\");\naudioChunksRef.current=[];};mediaRecorderRef.current.onstop=async()=>{// console.log(\"Recording stopped, processing chunks...\");\nconst audioBlob=new Blob(audioChunksRef.current,{type:mimeType});// console.log(\"Created blob of size:\", audioBlob.size, \"bytes\");\nif(audioUrl){URL.revokeObjectURL(audioUrl);}const url=URL.createObjectURL(audioBlob);setAudioUrl(url);if(audioElementRef.current){audioElementRef.current.load();}};mediaRecorderRef.current.onerror=event=>{console.error(\"MediaRecorder error:\",event.error);setError(\"Recording error: \"+event.error.message);};setIsStreamReady(true);setError(null);}catch(error){console.error(\"Error initializing audio stream:\",error);setError(\"Error accessing microphone: \"+error.message);setIsStreamReady(false);}};const cleanupAudioStream=()=>{// console.log(\"Cleaning up audio stream...\");\nif(mediaRecorderRef.current&&isRecording){mediaRecorderRef.current.stop();}if(mediaStreamRef.current){mediaStreamRef.current.getTracks().forEach(track=>{track.stop();// console.log(\"Track stopped:\", track.kind);\n});}if(audioUrl){URL.revokeObjectURL(audioUrl);}setIsStreamReady(false);setAudioUrl(null);setIsRecording(false);// console.log(\"Cleanup complete\");\n};const startRecording=async()=>{try{if(!isStreamReady){await initAudioStream();}if(!mediaRecorderRef.current||mediaRecorderRef.current.state===\"inactive\"){// console.log(\"Starting recording...\");\naudioChunksRef.current=[];mediaRecorderRef.current.start(1000);// Collect data every second\nsetIsRecording(true);setError(null);}}catch(error){console.error(\"Error starting recording:\",error);setError(\"Error starting recording: \"+error.message);}};const stopRecording=async()=>{try{if(mediaRecorderRef.current&&mediaRecorderRef.current.state!==\"inactive\"){// console.log(\"Stopping recording...\");\nmediaRecorderRef.current.stop();setIsRecording(false);}}catch(error){console.error(\"Error stopping recording:\",error);setError(\"Error stopping recording: \"+error.message);}};return{isRecording,error,audioUrl,startRecording,stopRecording};}","map":{"version":3,"names":["useEffect","useRef","useState","useRecordAudio","isRecording","setIsRecording","audioUrl","setAudioUrl","isStreamReady","setIsStreamReady","error","setError","mediaStreamRef","mediaRecorderRef","audioChunksRef","audioElementRef","initAudioStream","cleanupAudioStream","URL","revokeObjectURL","stream","navigator","mediaDevices","getUserMedia","audio","channelCount","sampleRate","current","mimeType","MediaRecorder","isTypeSupported","ondataavailable","event","data","size","push","onstart","onstop","audioBlob","Blob","type","url","createObjectURL","load","onerror","console","message","stop","getTracks","forEach","track","startRecording","state","start","stopRecording"],"sources":["/home/samoore/tpd/new/src/hooks/useRecordAudio.js"],"sourcesContent":["import { useEffect, useRef, useState } from \"react\";\r\n\r\nexport function useRecordAudio() {\r\n  const [isRecording, setIsRecording] = useState(false);\r\n  const [audioUrl, setAudioUrl] = useState(null);\r\n  const [isStreamReady, setIsStreamReady] = useState(false);\r\n  const [error, setError] = useState(null);\r\n\r\n  const mediaStreamRef = useRef(null);\r\n  const mediaRecorderRef = useRef(null);\r\n  const audioChunksRef = useRef([]);\r\n  const audioElementRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    initAudioStream();\r\n    return () => {\r\n      cleanupAudioStream();\r\n      if (audioUrl) {\r\n        URL.revokeObjectURL(audioUrl);\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const initAudioStream = async () => {\r\n    try {\r\n      // console.log(\"Requesting microphone access...\");\r\n      const stream = await navigator.mediaDevices.getUserMedia({\r\n        audio: {\r\n          channelCount: 1,\r\n          sampleRate: 16000,\r\n        },\r\n      });\r\n      // console.log(\"Microphone access granted\");\r\n\r\n      mediaStreamRef.current = stream;\r\n\r\n      // Check available MIME types\r\n      const mimeType = MediaRecorder.isTypeSupported(\"audio/webm\")\r\n        ? \"audio/webm\"\r\n        : MediaRecorder.isTypeSupported(\"audio/mp4\")\r\n        ? \"audio/mp4\"\r\n        : \"audio/ogg\";\r\n\r\n      // console.log(\"Using MIME type:\", mimeType);\r\n\r\n      mediaRecorderRef.current = new MediaRecorder(stream, {\r\n        mimeType: mimeType,\r\n      });\r\n\r\n      mediaRecorderRef.current.ondataavailable = (event) => {\r\n        // console.log(\"Data available:\", event.data.size, \"bytes\");\r\n        if (event.data.size > 0) {\r\n          audioChunksRef.current.push(event.data);\r\n        }\r\n      };\r\n\r\n      mediaRecorderRef.current.onstart = () => {\r\n        // console.log(\"Recording started\");\r\n        audioChunksRef.current = [];\r\n      };\r\n\r\n      mediaRecorderRef.current.onstop = async () => {\r\n        // console.log(\"Recording stopped, processing chunks...\");\r\n        const audioBlob = new Blob(audioChunksRef.current, { type: mimeType });\r\n        // console.log(\"Created blob of size:\", audioBlob.size, \"bytes\");\r\n\r\n        if (audioUrl) {\r\n          URL.revokeObjectURL(audioUrl);\r\n        }\r\n\r\n        const url = URL.createObjectURL(audioBlob);\r\n        setAudioUrl(url);\r\n\r\n        if (audioElementRef.current) {\r\n          audioElementRef.current.load();\r\n        }\r\n      };\r\n\r\n      mediaRecorderRef.current.onerror = (event) => {\r\n        console.error(\"MediaRecorder error:\", event.error);\r\n        setError(\"Recording error: \" + event.error.message);\r\n      };\r\n\r\n      setIsStreamReady(true);\r\n      setError(null);\r\n    } catch (error) {\r\n      console.error(\"Error initializing audio stream:\", error);\r\n      setError(\"Error accessing microphone: \" + error.message);\r\n      setIsStreamReady(false);\r\n    }\r\n  };\r\n\r\n  const cleanupAudioStream = () => {\r\n    // console.log(\"Cleaning up audio stream...\");\r\n    if (mediaRecorderRef.current && isRecording) {\r\n      mediaRecorderRef.current.stop();\r\n    }\r\n    if (mediaStreamRef.current) {\r\n      mediaStreamRef.current.getTracks().forEach((track) => {\r\n        track.stop();\r\n        // console.log(\"Track stopped:\", track.kind);\r\n      });\r\n    }\r\n    if (audioUrl) {\r\n      URL.revokeObjectURL(audioUrl);\r\n    }\r\n    setIsStreamReady(false);\r\n    setAudioUrl(null);\r\n    setIsRecording(false);\r\n    // console.log(\"Cleanup complete\");\r\n  };\r\n\r\n  const startRecording = async () => {\r\n    try {\r\n      if (!isStreamReady) {\r\n        await initAudioStream();\r\n      }\r\n\r\n      if (\r\n        !mediaRecorderRef.current ||\r\n        mediaRecorderRef.current.state === \"inactive\"\r\n      ) {\r\n        // console.log(\"Starting recording...\");\r\n        audioChunksRef.current = [];\r\n        mediaRecorderRef.current.start(1000); // Collect data every second\r\n        setIsRecording(true);\r\n        setError(null);\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Error starting recording:\", error);\r\n      setError(\"Error starting recording: \" + error.message);\r\n    }\r\n  };\r\n\r\n  const stopRecording = async () => {\r\n    try {\r\n      if (\r\n        mediaRecorderRef.current &&\r\n        mediaRecorderRef.current.state !== \"inactive\"\r\n      ) {\r\n        // console.log(\"Stopping recording...\");\r\n        mediaRecorderRef.current.stop();\r\n        setIsRecording(false);\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Error stopping recording:\", error);\r\n      setError(\"Error stopping recording: \" + error.message);\r\n    }\r\n  };\r\n\r\n  return { isRecording, error, audioUrl, startRecording, stopRecording };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}