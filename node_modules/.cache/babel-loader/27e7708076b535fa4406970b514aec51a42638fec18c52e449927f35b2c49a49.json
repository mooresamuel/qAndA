{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useState } from \"react\";\nimport { wordScoresAPI } from \"../services/wordScoresApi\";\nimport { useRecordAudio } from \"./useRecordAudio\";\nexport function useSpeechToText(text) {\n  _s();\n  const {\n    isRecording,\n    audioUrl,\n    startRecording: startRec,\n    stopRecording\n  } = useRecordAudio();\n  const [result, setResult] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  useEffect(function () {\n    async function action() {\n      await sendRecording();\n    }\n    action();\n  }, [audioUrl]);\n  const sendRecording = async () => {\n    if (!audioUrl) {\n      // || !phrase) {\n      setError(\"Please record audio and enter a phrase first\");\n      return;\n    }\n    setIsLoading(true);\n    try {\n      const response = await fetch(audioUrl);\n      const audioBlob = await response.blob();\n      console.log(\"Sending blob of size:\", audioBlob.size, \"bytes\");\n      const formData = new FormData();\n      formData.append(\"audio\", audioBlob, \"recording.webm\");\n      formData.append(\"phrase\", text);\n      console.log(\"recording being sent\");\n      const data = await wordScoresAPI(formData);\n      setResult(data);\n      console.log(\"Result:\", data);\n      setError(null);\n    } catch (error) {\n      console.error(\"Error sending recording:\", error);\n      setError(\"Error sending recording: \" + error.message);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  const startRecording = async () => {\n    setResult(\"\");\n    await startRec();\n  };\n  return {\n    isRecording,\n    isLoading,\n    audioUrl,\n    result,\n    error,\n    startRecording,\n    stopRecording,\n    sendRecording\n  };\n}\n_s(useSpeechToText, \"ihFSw8tmPzGTNt1HuxSW3Wz8MUo=\", false, function () {\n  return [useRecordAudio];\n});","map":{"version":3,"names":["useEffect","useRef","useState","wordScoresAPI","useRecordAudio","useSpeechToText","text","_s","isRecording","audioUrl","startRecording","startRec","stopRecording","result","setResult","isLoading","setIsLoading","error","setError","action","sendRecording","response","fetch","audioBlob","blob","console","log","size","formData","FormData","append","data","message"],"sources":["/home/samoore/tpd/new/src/hooks/useSpeechToText.js"],"sourcesContent":["import { useEffect, useRef, useState } from \"react\";\r\nimport { wordScoresAPI } from \"../services/wordScoresApi\";\r\nimport { useRecordAudio } from \"./useRecordAudio\";\r\n\r\nexport function useSpeechToText(text) {\r\n  const {\r\n    isRecording,\r\n    audioUrl,\r\n    startRecording: startRec,\r\n    stopRecording,\r\n  } = useRecordAudio();\r\n  const [result, setResult] = useState(\"\");\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [error, setError] = useState(null);\r\n\r\n  useEffect(\r\n    function () {\r\n      async function action() {\r\n        await sendRecording();\r\n      }\r\n\r\n      action();\r\n    },\r\n    [audioUrl]\r\n  );\r\n\r\n  const sendRecording = async () => {\r\n    if (!audioUrl) {\r\n      // || !phrase) {\r\n      setError(\"Please record audio and enter a phrase first\");\r\n      return;\r\n    }\r\n\r\n    setIsLoading(true);\r\n    try {\r\n      const response = await fetch(audioUrl);\r\n      const audioBlob = await response.blob();\r\n      console.log(\"Sending blob of size:\", audioBlob.size, \"bytes\");\r\n\r\n      const formData = new FormData();\r\n      formData.append(\"audio\", audioBlob, \"recording.webm\");\r\n      formData.append(\"phrase\", text);\r\n      console.log(\"recording being sent\");\r\n      const data = await wordScoresAPI(formData);\r\n      setResult(data);\r\n      console.log(\"Result:\", data);\r\n      setError(null);\r\n    } catch (error) {\r\n      console.error(\"Error sending recording:\", error);\r\n      setError(\"Error sending recording: \" + error.message);\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  const startRecording = async () => {\r\n    setResult(\"\");\r\n    await startRec();\r\n  };\r\n\r\n  return {\r\n    isRecording,\r\n    isLoading,\r\n    audioUrl,\r\n    result,\r\n    error,\r\n    startRecording,\r\n    stopRecording,\r\n    sendRecording,\r\n  };\r\n}\r\n"],"mappings":";AAAA,SAASA,SAAS,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AACnD,SAASC,aAAa,QAAQ,2BAA2B;AACzD,SAASC,cAAc,QAAQ,kBAAkB;AAEjD,OAAO,SAASC,eAAeA,CAACC,IAAI,EAAE;EAAAC,EAAA;EACpC,MAAM;IACJC,WAAW;IACXC,QAAQ;IACRC,cAAc,EAAEC,QAAQ;IACxBC;EACF,CAAC,GAAGR,cAAc,CAAC,CAAC;EACpB,MAAM,CAACS,MAAM,EAAEC,SAAS,CAAC,GAAGZ,QAAQ,CAAC,EAAE,CAAC;EACxC,MAAM,CAACa,SAAS,EAAEC,YAAY,CAAC,GAAGd,QAAQ,CAAC,KAAK,CAAC;EACjD,MAAM,CAACe,KAAK,EAAEC,QAAQ,CAAC,GAAGhB,QAAQ,CAAC,IAAI,CAAC;EAExCF,SAAS,CACP,YAAY;IACV,eAAemB,MAAMA,CAAA,EAAG;MACtB,MAAMC,aAAa,CAAC,CAAC;IACvB;IAEAD,MAAM,CAAC,CAAC;EACV,CAAC,EACD,CAACV,QAAQ,CACX,CAAC;EAED,MAAMW,aAAa,GAAG,MAAAA,CAAA,KAAY;IAChC,IAAI,CAACX,QAAQ,EAAE;MACb;MACAS,QAAQ,CAAC,8CAA8C,CAAC;MACxD;IACF;IAEAF,YAAY,CAAC,IAAI,CAAC;IAClB,IAAI;MACF,MAAMK,QAAQ,GAAG,MAAMC,KAAK,CAACb,QAAQ,CAAC;MACtC,MAAMc,SAAS,GAAG,MAAMF,QAAQ,CAACG,IAAI,CAAC,CAAC;MACvCC,OAAO,CAACC,GAAG,CAAC,uBAAuB,EAAEH,SAAS,CAACI,IAAI,EAAE,OAAO,CAAC;MAE7D,MAAMC,QAAQ,GAAG,IAAIC,QAAQ,CAAC,CAAC;MAC/BD,QAAQ,CAACE,MAAM,CAAC,OAAO,EAAEP,SAAS,EAAE,gBAAgB,CAAC;MACrDK,QAAQ,CAACE,MAAM,CAAC,QAAQ,EAAExB,IAAI,CAAC;MAC/BmB,OAAO,CAACC,GAAG,CAAC,sBAAsB,CAAC;MACnC,MAAMK,IAAI,GAAG,MAAM5B,aAAa,CAACyB,QAAQ,CAAC;MAC1Cd,SAAS,CAACiB,IAAI,CAAC;MACfN,OAAO,CAACC,GAAG,CAAC,SAAS,EAAEK,IAAI,CAAC;MAC5Bb,QAAQ,CAAC,IAAI,CAAC;IAChB,CAAC,CAAC,OAAOD,KAAK,EAAE;MACdQ,OAAO,CAACR,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;MAChDC,QAAQ,CAAC,2BAA2B,GAAGD,KAAK,CAACe,OAAO,CAAC;IACvD,CAAC,SAAS;MACRhB,YAAY,CAAC,KAAK,CAAC;IACrB;EACF,CAAC;EAED,MAAMN,cAAc,GAAG,MAAAA,CAAA,KAAY;IACjCI,SAAS,CAAC,EAAE,CAAC;IACb,MAAMH,QAAQ,CAAC,CAAC;EAClB,CAAC;EAED,OAAO;IACLH,WAAW;IACXO,SAAS;IACTN,QAAQ;IACRI,MAAM;IACNI,KAAK;IACLP,cAAc;IACdE,aAAa;IACbQ;EACF,CAAC;AACH;AAACb,EAAA,CAlEeF,eAAe;EAAA,QAMzBD,cAAc;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}